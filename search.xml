<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[Mac安装Mongodb详解]]></title>
      <url>/2018/03/27/Mac%E5%AE%89%E8%A3%85Mongodb%E8%AF%A6%E8%A7%A3/</url>
      <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><ul>
<li>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引(来自百度).</li>
<li>因为在开发中需要使用Mongodb，所以本文主要讲解Mac环境下的Mongodb的安装，在之后讲解其使用.<a id="more"></a>
</li>
</ul>
<h3 id="Mongodb安装"><a href="#Mongodb安装" class="headerlink" title="Mongodb安装"></a>Mongodb安装</h3><p>在官方文档中已经讲解过Mongodb的安装方法<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/" target="_blank" rel="noopener">官方安装文档</a>，主要为下载安装与brew安装两种方式，本文主要讲解下载安装方式.</p>
<ul>
<li>Mongodb下载<br><a href="https://www.mongodb.com/download-center?jmp=nav#community" target="_blank" rel="noopener">下载地址</a><br>点击上方下载地址，如下图所示:<br><img src="/2018/03/27/Mac安装Mongodb详解/1.png" alt="1"><br>可点击图中下载按钮直接进行下载，同时也可以通过curl进行下载，执行如下命令即可:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -0 https://fastdl.mongodb.org/osx/mongodb-osx-ssl-x86_64-3.6.3.tgz</span><br></pre></td></tr></table></figure>
<p>我选择的是下载包的方式，点击下图所示链接跳转:<br><img src="/2018/03/27/Mac安装Mongodb详解/2.png" alt="点击跳转"></p>
<p>跳转到包下载页面后，我选择了3.6.3的版本，如下图所示:<br><img src="/2018/03/27/Mac安装Mongodb详解/3.png" alt="下载"></p>
<ul>
<li><p>安装<br>安装主要分为几步，如下所示.</p>
<ul>
<li><p>解压安装</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cd Downloads</span><br><span class="line">➜  ~ mv mongodb-osx-ssl-x86_64-3.6.3.tgz /usr/local</span><br><span class="line"></span><br><span class="line">&lt;!-- 解压 --&gt;</span><br><span class="line">➜  tar -zxvf mongodb-osx-ssl-x86_64-3.6.3.tgz</span><br><span class="line"></span><br><span class="line">&lt;!-- 重命名 --&gt;</span><br><span class="line">➜  mv mongodb-osx-x86_64-3.6.3 mongodb-3.6.3</span><br></pre></td></tr></table></figure>
</li>
<li><p>环境变量配置</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  vim ~/.zshrc</span><br></pre></td></tr></table></figure>
<p>添加如下内容:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mongodb</span><br><span class="line">export PATH=/usr/local/mongodb-3.6.3/bin:$PATH</span><br></pre></td></tr></table></figure>
<p>使用配置生效:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  source ~/.zshrc</span><br></pre></td></tr></table></figure>
</li>
</ul>
</li>
<li><p>配置<br>这时候输入mongod命令启动Mongod，报如下错误:<br><img src="/2018/03/27/Mac安装Mongodb详解/4.png" alt="启动报错"><br>通过错误:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-03-27T18:32:19.012+0800 I STORAGE  [initandlisten] exception in initAndListen: IllegalOperation: Attempted to create a lock file on a read-only directory: /data/db, terminating</span><br><span class="line">2018-03-27T18:32:19.012+0800 I CONTROL  [initandlisten] now exiting</span><br><span class="line">2018-03-27T18:32:19.012+0800 I CONTROL  [initandlisten] shutting down with code:100</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>可以看出，这是因为mongodb存储数据的文件夹不能打开(mongodb数据文件存储在/data/db目录下)。<br>这里有两种解决办法：</p>
<ul>
<li><p>新建/data/db目录<br>新建目录后，通过如下命令启动mongodb:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  mongod --dbpath /data/db</span><br></pre></td></tr></table></figure>
</li>
<li><p>通过配置文件进行启动<br>Mongodb的配置文件存放在(/usr/local/etc)目录，内容如下:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">destination: file</span><br><span class="line">path: /usr/local/var/log/mongodb/mongo.log</span><br><span class="line">logAppend: true</span><br><span class="line">storage:</span><br><span class="line">dbPath: /usr/local/var/mongodb</span><br><span class="line">net:</span><br><span class="line">bindIp: 127.0.0.1</span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>配置文件中主要包括日志(log)的存储路径以及数据问价的存储路径(dbpath)，下一步则首先检查这些目录以及文件是否存在，如果没有存在则新建，检查完毕后，通过如下命令即可启动:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  mongod --config /usr/local/etc/mongod.conf</span><br></pre></td></tr></table></figure></p>
<p>启动后，通过如下命令启动服务端:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  mongo</span><br></pre></td></tr></table></figure></p>
<p>启动成功后如下图所示:<br><img src="/2018/03/27/Mac安装Mongodb详解/5.png" alt="启动"></p>]]></content>
      
        <categories>
            
            <category> 软件安装 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Mongodb </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Golang框架Gin的入门使用]]></title>
      <url>/2018/03/26/Golang%E6%A1%86%E6%9E%B6Gin%E7%9A%84%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/</url>
      <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><ul>
<li>Gin是一个golang的微框架，封装比较优雅，API友好，源码注释比较明确，已经发布了1.0版本。具有快速灵活，容错方便等特点，目前在app以及web端的使用都比较多.</li>
<li>在本文中主要通过一个简单的例子对其进行简单的记录，方便在之后的使用中能够方便的查阅基础知识.<a id="more"></a>
</li>
</ul>
<h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul>
<li><a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">Gin-Github</a></li>
<li><a href="https://godoc.org/github.com/gin-gonic/gin" target="_blank" rel="noopener">Gindoc</a></li>
<li><a href="https://github.com/Swxctx/mygo/blob/master/gin/ginbase.go" target="_blank" rel="noopener">本文源码</a></li>
</ul>
<h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ul>
<li>数据库连接<br>在本文中通过对数据库的插入以及查询完成gin的两个接口，以便对gin有一个初步的了解。本文使用<a href="https://github.com/go-sql-driver/mysql" target="_blank" rel="noopener">go-sql-driver</a>完成对MySql数据库的驱动及先关操作,代码如下所示:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db, err := sql.Open(&quot;mysql&quot;, &quot;root:@tcp(127.0.0.1:3306)/test?parseTime=true&quot;)</span><br><span class="line">defer db.Close()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">db.SetMaxIdleConns(20)</span><br><span class="line">db.SetMaxOpenConns(20)</span><br><span class="line">if err := db.Ping(); err != nil &#123;</span><br><span class="line">    log.Fatalln(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里需要根据自己的MySql配置来做相应的调整，具体可见go-sql-driver详细说明。</p>
<ul>
<li>router声明<br>需要首先声明router，用于接下来的接口操作，代码如下:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router := gin.Default()</span><br></pre></td></tr></table></figure>
<ul>
<li>数据插入操作<br>该接口通过传入两个参数完成数据库数据的插入功能，代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">router.GET(&quot;/insert&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		firstName := c.Request.FormValue(&quot;first_name&quot;)</span><br><span class="line">		lastName := c.Request.FormValue(&quot;last_name&quot;)</span><br><span class="line">		rs, err := db.Exec(&quot;INSERT INTO person(first_name, last_name) VALUES (?, ?)&quot;, firstName, lastName)</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			log.Fatalln(err)</span><br><span class="line">		&#125;</span><br><span class="line">		id, err := rs.LastInsertId()</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			log.Fatalln(err)</span><br><span class="line">		&#125;</span><br><span class="line">		fmt.Println(&quot;insert person Id &#123;&#125;&quot;, id)</span><br><span class="line">		msg := fmt.Sprintf(&quot;insert successful %d&quot;, id)</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;&quot;msg&quot;: msg&#125;)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p>在上面的代码中，主要分为三个部分，分别为获取参数、业务逻辑、数据相应三个部分。</p>
<pre><code>- 获取参数
gin提供了简便的方法为我们获取请求参数所使用，如下代码所示:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  	firstName := c.Request.FormValue(&quot;first_name&quot;)</span><br><span class="line">lastName := c.Request.FormValue(&quot;last_name&quot;)</span><br></pre></td></tr></table></figure>

- 业务逻辑
在此接口中，主要的业务逻辑就是实现数据的插入功能，在之前已经对MySql做了驱动，所以在这里直接使用即可:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  rs, err := db.Exec(&quot;INSERT INTO person(first_name, last_name) VALUES (?, ?)&quot;, firstName, lastName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">	log.Fatalln(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

- 数据响应
在进行接口编写时需要有数据响应给前端做相应的处理，在这里gin也封装了数据相应的方法及解释，我们直接进行调用即可:
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  	id, err := rs.LastInsertId()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">	log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;insert person Id &#123;&#125;&quot;, id)</span><br><span class="line">msg := fmt.Sprintf(&quot;insert successful %d&quot;, id)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;&quot;msg&quot;: msg&#125;)</span><br></pre></td></tr></table></figure>
</code></pre><ul>
<li>数据查询接口<br>数据查询与之前的插入其实并没有太大的差别，只是需要对查询到的数据做一个解析操作，以便对前端做出规定格式的数据响应，代码如下：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">router.GET(&quot;/query&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		rows, err := db.Query(&quot;SELECT id, first_name, last_name FROM person&quot;)</span><br><span class="line">		defer rows.Close()</span><br><span class="line">		if err != nil &#123;</span><br><span class="line">			log.Fatalln(err)</span><br><span class="line">		&#125;</span><br><span class="line">		persons := make([]Person, 0)</span><br><span class="line">		for rows.Next() &#123;</span><br><span class="line">			var person Person</span><br><span class="line">			rows.Scan(&amp;person.Id, &amp;person.FirstName, &amp;person.LastName)</span><br><span class="line">			persons = append(persons, person)</span><br><span class="line">		&#125;</span><br><span class="line">		if err = rows.Err(); err != nil &#123;</span><br><span class="line">			log.Fatalln(err)</span><br><span class="line">		&#125;</span><br><span class="line">		c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">			&quot;persons&quot;: persons,</span><br><span class="line">		&#125;)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<ul>
<li>路径参数<br>在gin中我们也可以像Java一样使用action来对path做解析，但这里又与Java有所不同，直接看代码或许比较直观：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.GET(&quot;/user/:name/*action&quot;, func(c *gin.Context) &#123;</span><br><span class="line">		name := c.Param(&quot;name&quot;)</span><br><span class="line">		action := c.Param(&quot;action&quot;)</span><br><span class="line">		message := name + &quot; is &quot; + action</span><br><span class="line">		c.String(http.StatusOK, message)</span><br><span class="line">	&#125;)</span><br></pre></td></tr></table></figure>
<p>入代码所示，在使用时检测name与action，如果我们的path为/user/gin/test，那么解析到的name就是gin，而action就是test.</p>
<p>demo运行如图所示:<br><img src="/2018/03/26/Golang框架Gin的入门使用/run.png" alt="run"></p>]]></content>
      
        <categories>
            
            <category> Gin </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Golang几种排序方式的实现及比较]]></title>
      <url>/2018/03/26/Golang%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%AF%94%E8%BE%83/</url>
      <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><ul>
<li>之前在工作中需要用到排序算法，并且数据量较大，所以做了一些测试，主要包括选择排序、冒泡排序、二分法、快速排序等，本文主要通过代码以及实现进行讲解<a id="more"></a>
待更…</li>
</ul>]]></content>
      
        <categories>
            
            <category> sort </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Golang实现简单的邮件发送]]></title>
      <url>/2018/03/26/Golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/</url>
      <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><ul>
<li>Golang中提供了net/smtp包提供邮件的发送功能，但是在目前已经有了封装成熟的邮件发送包-Gomail，<a href="https://github.com/go-gomail/gomail" target="_blank" rel="noopener">点击此处访问项目GitHub</a>.</li>
<li>在之前的一篇CSDN博客中，我详细的描述过Java对邮件发送、接收以及转发等操作，<a href="https://blog.csdn.net/qq_28796345/article/details/53366324" target="_blank" rel="noopener">点击此处访问Java Mail详解</a>，所以在这里也不再讲述SMTP以及POP这些邮件协议，直接通过通过gomail包来发送邮件.<a id="more"></a>
</li>
</ul>
<h3 id="Goloang-gomail"><a href="#Goloang-gomail" class="headerlink" title="Goloang-gomail"></a>Goloang-gomail</h3><p>使用gomail包来进行邮件发送时，操作很简单，只需要调用设置好消息体以及通过认证就可以进行邮件的发送，代码如下所示：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">	&quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">	&quot;gopkg.in/gomail.v2&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">	m := gomail.NewMessage()</span><br><span class="line">	// 发件人</span><br><span class="line">	m.SetAddressHeader(&quot;From&quot;, &quot;swxctx@sina.com&quot;, &quot;Golang-Mail-Test&quot;)</span><br><span class="line">	// 收件人</span><br><span class="line">	m.SetHeader(&quot;To&quot;, m.FormatAddress(&quot;swxctx@sina.cn&quot;, &quot;go-mail&quot;))</span><br><span class="line">	// 主题</span><br><span class="line">	m.SetHeader(&quot;Subject&quot;, &quot;Gomail&quot;)</span><br><span class="line">	// 发送的body体</span><br><span class="line">	m.SetBody(&quot;text/html&quot;, &quot;&lt;h4&gt;我的测试邮件&lt;h4&gt;&lt;a href = \&quot;http://www.swxctx.top\&quot;&gt;看看我的网站&lt;/a&gt;&quot;)</span><br><span class="line"></span><br><span class="line">	// 发送邮件服务器、端口、发件人账号、发件人密码</span><br><span class="line">	d := gomail.NewPlainDialer(&quot;smtp.sina.com&quot;, 25, &quot;swxctx@sina.com&quot;, &quot;****&quot;)</span><br><span class="line">	if err := d.DialAndSend(m); err != nil &#123;</span><br><span class="line">		panic(err)</span><br><span class="line">	&#125;</span><br><span class="line">	fmt.Println(&quot;mail send success...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在这里只需要关注于body体的编写，这里可以使用多种Content-type，比如text/html、string等。</p>
<p>发送成功如图所示：<br><img src="/2018/03/26/Golang实现简单的邮件发送/gmail.png" alt="mail"></p>]]></content>
      
        <categories>
            
            <category> gloang </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 各语言邮件发送 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Golang实现的简单爬虫]]></title>
      <url>/2018/02/11/Golang%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/</url>
      <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>今天在工作上面需要用到爬虫抓取部分信息，之前用Python实现了CSDN博客的抓取，后想到了目前整天面对的Golang，便摸索了一下，实现了一个简单的抓取豆瓣排行的爬虫，主要分为下面几个步骤.</p>
<ul>
<li>发起Http请求</li>
<li>解析Html元素</li>
<li>存储抓取到的数据<a id="more"></a>
</li>
</ul>
<h3 id="发起http请求"><a href="#发起http请求" class="headerlink" title="发起http请求"></a>发起http请求</h3><p>在请求方面，直接采用的Golang的”net/http”包来进行开发，步骤如下:</p>
<ul>
<li>初始化</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">req, err := http.NewRequest(&quot;GET&quot;, swoop.url, nil)</span><br></pre></td></tr></table></figure>
<ul>
<li>set请求信息</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for key, value := range swoop.header &#123;</span><br><span class="line">    req.Header.Add(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>发起请求</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resp, err := client.Do(req)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    log.Fatalf(&quot;do client err-&gt;%v&quot;, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>接收响应</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    log.Fatalf(&quot;read resp err-&gt;%v&quot;, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="解析Html元素"><a href="#解析Html元素" class="headerlink" title="解析Html元素"></a>解析Html元素</h3><ul>
<li>设置参数并请求<br>首先需要定义个设置参数结构体，便于操作:</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Swoop struct &#123;</span><br><span class="line">    url    string</span><br><span class="line">    header map[string]string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>设置参数后发起请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url := &quot;https://movie.douban.com/top250?start=&quot; + strconv.Itoa(i*25)</span><br><span class="line">swoop := &amp;Swoop&#123;url, header&#125;</span><br><span class="line">html := swoop.get_html_header()</span><br></pre></td></tr></table></figure></p>
<ul>
<li>解析Html元素<br>发起请求后，接收到Html元素，接下来需要做的就是解析Html元素，将其转化为我们想要的格式，解析Html格式需要到页面浏览器查看对应的Html元素后再做操作：</li>
</ul>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//评价人数</span><br><span class="line">commentCount := `&lt;span&gt;(.*?)评价&lt;/span&gt;`</span><br><span class="line">rp2 := regexp.MustCompile(commentCount)</span><br><span class="line">txt2 := rp2.FindAllStringSubmatch(html, -1)</span><br><span class="line"></span><br><span class="line">//评分</span><br><span class="line">pattern3 := `property=&quot;v:average&quot;&gt;(.*?)&lt;/span&gt;`</span><br><span class="line">rp3 := regexp.MustCompile(pattern3)</span><br><span class="line">txt3 := rp3.FindAllStringSubmatch(html, -1)</span><br><span class="line"></span><br><span class="line">//电影名称</span><br><span class="line">pattern4 := `img width=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; src=`</span><br><span class="line">rp4 := regexp.MustCompile(pattern4)</span><br><span class="line">txt4 := rp4.FindAllStringSubmatch(html, -1)</span><br></pre></td></tr></table></figure>
<p>如下Html页面代码，其中评价包含在”&lt;\span&gt;”标签内，所以在解析的时候需要解析&lt;\span&gt;标签:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;star&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;rating5-t&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;9.5&lt;/span&gt;</span><br><span class="line">    &lt;span property=&quot;v:best&quot; content=&quot;10.0&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;702861人评价&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p>如下页面代码，包含了width、alt、src三个value，则需要拿到title就需要解析&lt;\img&gt;标签后读取第二个value值，即alt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img width=&quot;100&quot; alt=&quot;这个杀手不太冷&quot; src=&quot;https://img3.doubanio.com/view/photo/s_ratio_poster/public/p511118051.jpg&quot; class=&quot;&quot;&gt;</span><br></pre></td></tr></table></figure></p>
<ul>
<li>运行代码后效果如下<br>运行中:<br><img src="/2018/02/11/Golang实现的简单爬虫/2_run.png" alt="run"></li>
</ul>
<p>运行结束:<br><img src="/2018/02/11/Golang实现的简单爬虫/2_result.png" alt="result"></p>
<h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>数据存储一般根据自己的需要来做，我这里采用的是csv文件存储.<br>如下所示:<br><img src="/2018/02/11/Golang实现的简单爬虫/2_print.png" alt="print"></p>
<h4 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h4><p><a href="https://github.com/Swxctx/mygo/tree/master/swoop/douban" target="_blank" rel="noopener">源代码链接</a></p>]]></content>
      
        <categories>
            
            <category> golang </category>
            
        </categories>
        
        
        <tags>
            
            <tag> Golang </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[First Content]]></title>
      <url>/2018/01/24/first-blog/</url>
      <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>该网站主要用于记录日常工作及学习中的一些知识点及简要代码，主要包含如下几类。</p>
<ul>
<li>Golang</li>
<li>C</li>
<li>C++</li>
<li>Java</li>
<li>机器学习</li>
<li>日常算法及文章分享</li>
<li>Linux编程及日常服务器维护<a id="more"></a>
如果有错误或不好的地方可通过’关于我’页面的联系方式与我联系，或者点击文章下方进行评论。</li>
</ul>]]></content>
      
        <categories>
            
            <category> base </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 基础 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
