<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Swxctx</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://www.swxctx.top/"/>
  <updated>2018-08-11T11:17:28.000Z</updated>
  <id>http://www.swxctx.top/</id>
  
  <author>
    <name>Swxctx</name>
    
  </author>
  
  <generator uri="http://hexo.io/">Hexo</generator>
  
  <entry>
    <title>Julia入门记</title>
    <link href="http://www.swxctx.top/2018/08/11/Julia%E5%85%A5%E9%97%A8%E8%AE%B0/"/>
    <id>http://www.swxctx.top/2018/08/11/Julia入门记/</id>
    <published>2018-08-11T10:12:42.000Z</published>
    <updated>2018-08-11T11:17:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>今天偶然看见了关于Julia相关的语言，其介绍是整合了C++、Python、Perl以及Ruby等多种语言的优势，使用JIT编译以及使用了LLVM，具有可选的类型声明，重载，高性能等特性；采用多编程范式，包含指令式、函数式和面向对象编程的特征，同时提供了简易和简洁的高等数值计算，类似于R语言、MATLAB以及Python；因为Julia采用了开源的方式，最大的优势其实就是可以在之后的发展中有大量的开发者为其做出大量工具以及包的贡献，所以想要入手试一下这个刚发布的Julia(1.0)版本。<br><a id="more"></a></p><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><p><a href="https://github.com/JuliaLang/julia" target="_blank" rel="noopener">GitHub</a><br><a href="https://julialang.org" target="_blank" rel="noopener">官方网站</a><br><a href="https://julialang.org/downloads/" target="_blank" rel="noopener">安装包下载</a><br><a href="https://docs.julialang.org/" target="_blank" rel="noopener">文档说明</a><br><a href="https://pkg.julialang.org/" target="_blank" rel="noopener">资源包</a><br><a href="https://github.com/JuliaLang/julia" target="_blank" rel="noopener">源码包</a></p><p>目前打算对Readme.md文件进行翻译，进行中文版以及使用方式支持，大家有兴趣的可以点击<a href="https://github.com/swxctx/julia" target="_blank" rel="noopener">我的Github</a>进行Fork提PR(Readme.Zn.md).</p><h3 id="安装"><a href="#安装" class="headerlink" title="安装"></a>安装</h3><p>通过在Github的介绍，Julia为我们提供了多种安装方式，包括: 源码包编译(比较复杂，需要具备多种语言环境)、安装包下载安装以及直接通过工具安装，因为测试电脑为Mac，所以比较方便，使用如下命令进行安装:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">brew install Caskroom/cask/julia</span><br></pre></td></tr></table></figure><p>安装过程中需要下载一些东西，所以大概需要3~5分钟的时间，安装界面如图:<br><img src="/2018/08/11/Julia入门记/install.jpg" alt="install"><br>入上图所示，表示Julia已经安装完成了，同样的，在进行每一个新东西的时候，最好的就是Help命令，如图所示:<br><img src="/2018/08/11/Julia入门记/help.png" alt="help"><br>下面运行Julia看一下会是什么效果，通过官方文档:<br>Once it is built, you can run the julia executable after you enter your julia directory and run<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">./julia</span><br></pre></td></tr></table></figure></p><p>可以运行命令./julia运行，我这里已经将其设置到环境变量中了，所以直接运行julia就可以，如下图所示:<br><img src="/2018/08/11/Julia入门记/run.png" alt="run"><br>如图所示，Julia已经启动了，那么该如何使用这门语言呢？</p><h3 id="简单入门使用"><a href="#简单入门使用" class="headerlink" title="简单入门使用"></a>简单入门使用</h3><p>在文章的开头已经介绍过Julia是一门多编程范式的语言，包含指令式编程，那么这代表我们可以像使用Shell一样的来使用它。首先当然离不开Hello Word，如图所示:<br><img src="/2018/08/11/Julia入门记/hello.png" alt="hello"><br>图中可以看出，我们可以直接通过println来进行输出，是不是很简单呢!<br>通过官方介绍可以看出，Julia主要进攻的领域其实就是数值计算，那么可以试一下它的数值计算是怎么样的，如图所示:<br><img src="/2018/08/11/Julia入门记/figure.png" alt="figure"><br>这样的语句的确是跟Shell很像，毕竟指令式的语言都不会有太大的差别。</p><p>上面已经讲了指令式的编程，那么接下来通过常规的编程方法来试试:</p><ol><li>新建first.jl(后缀名是.jl，这一点从源码可以看出)</li></ol><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">println(&quot;Hello Julia.&quot;)</span><br><span class="line">x = 1</span><br><span class="line">println(x)</span><br><span class="line">y = 2</span><br><span class="line">println(y)</span><br><span class="line">println(x + y)</span><br><span class="line">println(x - y)</span><br><span class="line">println(x * y)</span><br><span class="line">println(x / y)</span><br></pre></td></tr></table></figure><p>Julia的确是很简单的，不需要做任何的引入，也不需要进行变量的声明。</p><p>2.代码运行，如下图所示，跟大部分语言还是一样的：<br><img src="/2018/08/11/Julia入门记/firstjl.png" alt="first"><br>到这里，Julia的入手已经差不多了，接下来会继续对Julai进行深入学习，大家有兴趣的可以一起探索。</p><p>同时附带一些资源:<br><a href="https://github.com/swxctx/book" target="_blank" rel="noopener">学习资料</a><br><a href="https://github.com/swxctx/wechat" target="_blank" rel="noopener">Go语言微信公众平台SDK(有兴趣可以一起封装其他语言的SDK)</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h3&gt;&lt;p&gt;今天偶然看见了关于Julia相关的语言，其介绍是整合了C++、Python、Perl以及Ruby等多种语言的优势，使用JIT编译以及使用了LLVM，具有可选的类型声明，重载，高性能等特性；采用多编程范式，包含指令式、函数式和面向对象编程的特征，同时提供了简易和简洁的高等数值计算，类似于R语言、MATLAB以及Python；因为Julia采用了开源的方式，最大的优势其实就是可以在之后的发展中有大量的开发者为其做出大量工具以及包的贡献，所以想要入手试一下这个刚发布的Julia(1.0)版本。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
      <category term="语言基础" scheme="http://www.swxctx.top/categories/%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80/"/>
    
    
      <category term="Julia" scheme="http://www.swxctx.top/tags/Julia/"/>
    
  </entry>
  
  <entry>
    <title>Mac安装Mongodb详解</title>
    <link href="http://www.swxctx.top/2018/03/27/Mac%E5%AE%89%E8%A3%85Mongodb%E8%AF%A6%E8%A7%A3/"/>
    <id>http://www.swxctx.top/2018/03/27/Mac安装Mongodb详解/</id>
    <published>2018-03-27T10:31:56.000Z</published>
    <updated>2018-03-27T12:20:05.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><ul><li>MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引(来自百度).</li><li>因为在开发中需要使用Mongodb，所以本文主要讲解Mac环境下的Mongodb的安装，在之后讲解其使用.<a id="more"></a></li></ul><h3 id="Mongodb安装"><a href="#Mongodb安装" class="headerlink" title="Mongodb安装"></a>Mongodb安装</h3><p>在官方文档中已经讲解过Mongodb的安装方法<a href="https://docs.mongodb.com/manual/tutorial/install-mongodb-on-os-x/" target="_blank" rel="noopener">官方安装文档</a>，主要为下载安装与brew安装两种方式，本文主要讲解下载安装方式.</p><ul><li>Mongodb下载<br><a href="https://www.mongodb.com/download-center?jmp=nav#community" target="_blank" rel="noopener">下载地址</a><br>点击上方下载地址，如下图所示:<br><img src="/2018/03/27/Mac安装Mongodb详解/1.png" alt="1"><br>可点击图中下载按钮直接进行下载，同时也可以通过curl进行下载，执行如下命令即可:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -0 https://fastdl.mongodb.org/osx/mongodb-osx-ssl-x86_64-3.6.3.tgz</span><br></pre></td></tr></table></figure><p>我选择的是下载包的方式，点击下图所示链接跳转:<br><img src="/2018/03/27/Mac安装Mongodb详解/2.png" alt="点击跳转"></p><p>跳转到包下载页面后，我选择了3.6.3的版本，如下图所示:<br><img src="/2018/03/27/Mac安装Mongodb详解/3.png" alt="下载"></p><ul><li><p>安装<br>安装主要分为几步，如下所示.</p><ul><li><p>解压安装</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">➜  ~ cd Downloads</span><br><span class="line">➜  ~ mv mongodb-osx-ssl-x86_64-3.6.3.tgz /usr/local</span><br><span class="line"></span><br><span class="line">&lt;!-- 解压 --&gt;</span><br><span class="line">➜  tar -zxvf mongodb-osx-ssl-x86_64-3.6.3.tgz</span><br><span class="line"></span><br><span class="line">&lt;!-- 重命名 --&gt;</span><br><span class="line">➜  mv mongodb-osx-x86_64-3.6.3 mongodb-3.6.3</span><br></pre></td></tr></table></figure></li><li><p>环境变量配置</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  vim ~/.zshrc</span><br></pre></td></tr></table></figure><p>添加如下内容:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"># mongodb</span><br><span class="line">export PATH=/usr/local/mongodb-3.6.3/bin:$PATH</span><br></pre></td></tr></table></figure><p>使用配置生效:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  source ~/.zshrc</span><br></pre></td></tr></table></figure></li></ul></li><li><p>配置<br>这时候输入mongod命令启动Mongod，报如下错误:<br><img src="/2018/03/27/Mac安装Mongodb详解/4.png" alt="启动报错"><br>通过错误:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">2018-03-27T18:32:19.012+0800 I STORAGE  [initandlisten] exception in initAndListen: IllegalOperation: Attempted to create a lock file on a read-only directory: /data/db, terminating</span><br><span class="line">2018-03-27T18:32:19.012+0800 I CONTROL  [initandlisten] now exiting</span><br><span class="line">2018-03-27T18:32:19.012+0800 I CONTROL  [initandlisten] shutting down with code:100</span><br></pre></td></tr></table></figure></li></ul><p>可以看出，这是因为mongodb存储数据的文件夹不能打开(mongodb数据文件存储在/data/db目录下)。<br>这里有两种解决办法：</p><ul><li><p>新建/data/db目录<br>新建目录后，通过如下命令启动mongodb:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  mongod --dbpath /data/db</span><br></pre></td></tr></table></figure></li><li><p>通过配置文件进行启动<br>Mongodb的配置文件存放在(/usr/local/etc)目录，内容如下:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">systemLog:</span><br><span class="line">destination: file</span><br><span class="line">path: /usr/local/var/log/mongodb/mongo.log</span><br><span class="line">logAppend: true</span><br><span class="line">storage:</span><br><span class="line">dbPath: /usr/local/var/mongodb</span><br><span class="line">net:</span><br><span class="line">bindIp: 127.0.0.1</span><br></pre></td></tr></table></figure></li></ul><p>配置文件中主要包括日志(log)的存储路径以及数据问价的存储路径(dbpath)，下一步则首先检查这些目录以及文件是否存在，如果没有存在则新建，检查完毕后，通过如下命令即可启动:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  mongod --config /usr/local/etc/mongod.conf</span><br></pre></td></tr></table></figure></p><p>启动后，通过如下命令启动服务端:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">➜  mongo</span><br></pre></td></tr></table></figure></p><p>启动成功后如下图所示:<br><img src="/2018/03/27/Mac安装Mongodb详解/5.png" alt="启动"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;MongoDB是一个介于关系数据库和非关系数据库之间的产品，是非关系数据库当中功能最丰富，最像关系数据库的。他支持的数据结构非常松散，是类似json的bson格式，因此可以存储比较复杂的数据类型。Mongo最大的特点是他支持的查询语言非常强大，其语法有点类似于面向对象的查询语言，几乎可以实现类似关系数据库单表查询的绝大部分功能，而且还支持对数据建立索引(来自百度).&lt;/li&gt;
&lt;li&gt;因为在开发中需要使用Mongodb，所以本文主要讲解Mac环境下的Mongodb的安装，在之后讲解其使用.&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="软件安装" scheme="http://www.swxctx.top/categories/%E8%BD%AF%E4%BB%B6%E5%AE%89%E8%A3%85/"/>
    
    
      <category term="Mongodb" scheme="http://www.swxctx.top/tags/Mongodb/"/>
    
  </entry>
  
  <entry>
    <title>Golang框架Gin的入门使用</title>
    <link href="http://www.swxctx.top/2018/03/26/Golang%E6%A1%86%E6%9E%B6Gin%E7%9A%84%E5%85%A5%E9%97%A8%E4%BD%BF%E7%94%A8/"/>
    <id>http://www.swxctx.top/2018/03/26/Golang框架Gin的入门使用/</id>
    <published>2018-03-26T11:21:27.000Z</published>
    <updated>2018-03-27T06:16:00.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><ul><li>Gin是一个golang的微框架，封装比较优雅，API友好，源码注释比较明确，已经发布了1.0版本。具有快速灵活，容错方便等特点，目前在app以及web端的使用都比较多.</li><li>在本文中主要通过一个简单的例子对其进行简单的记录，方便在之后的使用中能够方便的查阅基础知识.<a id="more"></a></li></ul><h3 id="相关资料"><a href="#相关资料" class="headerlink" title="相关资料"></a>相关资料</h3><ul><li><a href="https://github.com/gin-gonic/gin" target="_blank" rel="noopener">Gin-Github</a></li><li><a href="https://godoc.org/github.com/gin-gonic/gin" target="_blank" rel="noopener">Gindoc</a></li><li><a href="https://github.com/Swxctx/mygo/blob/master/gin/ginbase.go" target="_blank" rel="noopener">本文源码</a></li></ul><h3 id="代码解释"><a href="#代码解释" class="headerlink" title="代码解释"></a>代码解释</h3><ul><li>数据库连接<br>在本文中通过对数据库的插入以及查询完成gin的两个接口，以便对gin有一个初步的了解。本文使用<a href="https://github.com/go-sql-driver/mysql" target="_blank" rel="noopener">go-sql-driver</a>完成对MySql数据库的驱动及先关操作,代码如下所示:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">db, err := sql.Open(&quot;mysql&quot;, &quot;root:@tcp(127.0.0.1:3306)/test?parseTime=true&quot;)</span><br><span class="line">defer db.Close()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">db.SetMaxIdleConns(20)</span><br><span class="line">db.SetMaxOpenConns(20)</span><br><span class="line">if err := db.Ping(); err != nil &#123;</span><br><span class="line">    log.Fatalln(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里需要根据自己的MySql配置来做相应的调整，具体可见go-sql-driver详细说明。</p><ul><li>router声明<br>需要首先声明router，用于接下来的接口操作，代码如下:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">router := gin.Default()</span><br></pre></td></tr></table></figure><ul><li>数据插入操作<br>该接口通过传入两个参数完成数据库数据的插入功能，代码如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">router.GET(&quot;/insert&quot;, func(c *gin.Context) &#123;</span><br><span class="line">firstName := c.Request.FormValue(&quot;first_name&quot;)</span><br><span class="line">lastName := c.Request.FormValue(&quot;last_name&quot;)</span><br><span class="line">rs, err := db.Exec(&quot;INSERT INTO person(first_name, last_name) VALUES (?, ?)&quot;, firstName, lastName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">id, err := rs.LastInsertId()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;insert person Id &#123;&#125;&quot;, id)</span><br><span class="line">msg := fmt.Sprintf(&quot;insert successful %d&quot;, id)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;&quot;msg&quot;: msg&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>在上面的代码中，主要分为三个部分，分别为获取参数、业务逻辑、数据相应三个部分。</p><pre><code>- 获取参数gin提供了简便的方法为我们获取请求参数所使用，如下代码所示:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">  firstName := c.Request.FormValue(&quot;first_name&quot;)</span><br><span class="line">lastName := c.Request.FormValue(&quot;last_name&quot;)</span><br></pre></td></tr></table></figure>- 业务逻辑在此接口中，主要的业务逻辑就是实现数据的插入功能，在之前已经对MySql做了驱动，所以在这里直接使用即可:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">  rs, err := db.Exec(&quot;INSERT INTO person(first_name, last_name) VALUES (?, ?)&quot;, firstName, lastName)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>- 数据响应在进行接口编写时需要有数据响应给前端做相应的处理，在这里gin也封装了数据相应的方法及解释，我们直接进行调用即可:<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">  id, err := rs.LastInsertId()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;insert person Id &#123;&#125;&quot;, id)</span><br><span class="line">msg := fmt.Sprintf(&quot;insert successful %d&quot;, id)</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;&quot;msg&quot;: msg&#125;)</span><br></pre></td></tr></table></figure></code></pre><ul><li>数据查询接口<br>数据查询与之前的插入其实并没有太大的差别，只是需要对查询到的数据做一个解析操作，以便对前端做出规定格式的数据响应，代码如下：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">router.GET(&quot;/query&quot;, func(c *gin.Context) &#123;</span><br><span class="line">rows, err := db.Query(&quot;SELECT id, first_name, last_name FROM person&quot;)</span><br><span class="line">defer rows.Close()</span><br><span class="line">if err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">persons := make([]Person, 0)</span><br><span class="line">for rows.Next() &#123;</span><br><span class="line">var person Person</span><br><span class="line">rows.Scan(&amp;person.Id, &amp;person.FirstName, &amp;person.LastName)</span><br><span class="line">persons = append(persons, person)</span><br><span class="line">&#125;</span><br><span class="line">if err = rows.Err(); err != nil &#123;</span><br><span class="line">log.Fatalln(err)</span><br><span class="line">&#125;</span><br><span class="line">c.JSON(http.StatusOK, gin.H&#123;</span><br><span class="line">&quot;persons&quot;: persons,</span><br><span class="line">&#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><ul><li>路径参数<br>在gin中我们也可以像Java一样使用action来对path做解析，但这里又与Java有所不同，直接看代码或许比较直观：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">router.GET(&quot;/user/:name/*action&quot;, func(c *gin.Context) &#123;</span><br><span class="line">name := c.Param(&quot;name&quot;)</span><br><span class="line">action := c.Param(&quot;action&quot;)</span><br><span class="line">message := name + &quot; is &quot; + action</span><br><span class="line">c.String(http.StatusOK, message)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><p>入代码所示，在使用时检测name与action，如果我们的path为/user/gin/test，那么解析到的name就是gin，而action就是test.</p><p>demo运行如图所示:<br><img src="/2018/03/26/Golang框架Gin的入门使用/run.png" alt="run"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Gin是一个golang的微框架，封装比较优雅，API友好，源码注释比较明确，已经发布了1.0版本。具有快速灵活，容错方便等特点，目前在app以及web端的使用都比较多.&lt;/li&gt;
&lt;li&gt;在本文中主要通过一个简单的例子对其进行简单的记录，方便在之后的使用中能够方便的查阅基础知识.&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="Gin" scheme="http://www.swxctx.top/categories/Gin/"/>
    
    
      <category term="Golang" scheme="http://www.swxctx.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang几种排序方式的实现及比较</title>
    <link href="http://www.swxctx.top/2018/03/26/Golang%E5%87%A0%E7%A7%8D%E6%8E%92%E5%BA%8F%E6%96%B9%E5%BC%8F%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8F%8A%E6%AF%94%E8%BE%83/"/>
    <id>http://www.swxctx.top/2018/03/26/Golang几种排序方式的实现及比较/</id>
    <published>2018-03-26T11:18:45.000Z</published>
    <updated>2018-03-27T10:45:28.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><ul><li>之前在工作中需要用到排序算法，并且数据量较大，所以做了一些测试，主要包括选择排序、冒泡排序、二分法、快速排序等，本文主要通过代码以及实现进行讲解<a id="more"></a>待更…</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;之前在工作中需要用到排序算法，并且数据量较大，所以做了一些测试，主要包括选择排序、冒泡排序、二分法、快速排序等，本文主要通过代码以及实现进行讲解&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="sort" scheme="http://www.swxctx.top/categories/sort/"/>
    
    
      <category term="Golang" scheme="http://www.swxctx.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>Golang实现简单的邮件发送</title>
    <link href="http://www.swxctx.top/2018/03/26/Golang%E5%AE%9E%E7%8E%B0%E7%AE%80%E5%8D%95%E7%9A%84%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"/>
    <id>http://www.swxctx.top/2018/03/26/Golang实现简单的邮件发送/</id>
    <published>2018-03-26T10:44:28.000Z</published>
    <updated>2018-03-26T11:02:38.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><ul><li>Golang中提供了net/smtp包提供邮件的发送功能，但是在目前已经有了封装成熟的邮件发送包-Gomail，<a href="https://github.com/go-gomail/gomail" target="_blank" rel="noopener">点击此处访问项目GitHub</a>.</li><li>在之前的一篇CSDN博客中，我详细的描述过Java对邮件发送、接收以及转发等操作，<a href="https://blog.csdn.net/qq_28796345/article/details/53366324" target="_blank" rel="noopener">点击此处访问Java Mail详解</a>，所以在这里也不再讲述SMTP以及POP这些邮件协议，直接通过通过gomail包来发送邮件.<a id="more"></a></li></ul><h3 id="Goloang-gomail"><a href="#Goloang-gomail" class="headerlink" title="Goloang-gomail"></a>Goloang-gomail</h3><p>使用gomail包来进行邮件发送时，操作很简单，只需要调用设置好消息体以及通过认证就可以进行邮件的发送，代码如下所示：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">package main</span><br><span class="line"></span><br><span class="line">import (</span><br><span class="line">&quot;fmt&quot;</span><br><span class="line"></span><br><span class="line">&quot;gopkg.in/gomail.v2&quot;</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">func main() &#123;</span><br><span class="line">m := gomail.NewMessage()</span><br><span class="line">// 发件人</span><br><span class="line">m.SetAddressHeader(&quot;From&quot;, &quot;swxctx@sina.com&quot;, &quot;Golang-Mail-Test&quot;)</span><br><span class="line">// 收件人</span><br><span class="line">m.SetHeader(&quot;To&quot;, m.FormatAddress(&quot;swxctx@sina.cn&quot;, &quot;go-mail&quot;))</span><br><span class="line">// 主题</span><br><span class="line">m.SetHeader(&quot;Subject&quot;, &quot;Gomail&quot;)</span><br><span class="line">// 发送的body体</span><br><span class="line">m.SetBody(&quot;text/html&quot;, &quot;&lt;h4&gt;我的测试邮件&lt;h4&gt;&lt;a href = \&quot;http://www.swxctx.top\&quot;&gt;看看我的网站&lt;/a&gt;&quot;)</span><br><span class="line"></span><br><span class="line">// 发送邮件服务器、端口、发件人账号、发件人密码</span><br><span class="line">d := gomail.NewPlainDialer(&quot;smtp.sina.com&quot;, 25, &quot;swxctx@sina.com&quot;, &quot;****&quot;)</span><br><span class="line">if err := d.DialAndSend(m); err != nil &#123;</span><br><span class="line">panic(err)</span><br><span class="line">&#125;</span><br><span class="line">fmt.Println(&quot;mail send success...&quot;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在这里只需要关注于body体的编写，这里可以使用多种Content-type，比如text/html、string等。</p><p>发送成功如图所示：<br><img src="/2018/03/26/Golang实现简单的邮件发送/gmail.png" alt="mail"></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;Golang中提供了net/smtp包提供邮件的发送功能，但是在目前已经有了封装成熟的邮件发送包-Gomail，&lt;a href=&quot;https://github.com/go-gomail/gomail&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击此处访问项目GitHub&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;在之前的一篇CSDN博客中，我详细的描述过Java对邮件发送、接收以及转发等操作，&lt;a href=&quot;https://blog.csdn.net/qq_28796345/article/details/53366324&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击此处访问Java Mail详解&lt;/a&gt;，所以在这里也不再讲述SMTP以及POP这些邮件协议，直接通过通过gomail包来发送邮件.&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="gloang" scheme="http://www.swxctx.top/categories/gloang/"/>
    
    
      <category term="各语言邮件发送" scheme="http://www.swxctx.top/tags/%E5%90%84%E8%AF%AD%E8%A8%80%E9%82%AE%E4%BB%B6%E5%8F%91%E9%80%81/"/>
    
  </entry>
  
  <entry>
    <title>Golang实现的简单爬虫</title>
    <link href="http://www.swxctx.top/2018/02/11/Golang%E5%AE%9E%E7%8E%B0%E7%9A%84%E7%AE%80%E5%8D%95%E7%88%AC%E8%99%AB/"/>
    <id>http://www.swxctx.top/2018/02/11/Golang实现的简单爬虫/</id>
    <published>2018-02-11T10:04:40.000Z</published>
    <updated>2018-02-11T11:00:07.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>今天在工作上面需要用到爬虫抓取部分信息，之前用Python实现了CSDN博客的抓取，后想到了目前整天面对的Golang，便摸索了一下，实现了一个简单的抓取豆瓣排行的爬虫，主要分为下面几个步骤.</p><ul><li>发起Http请求</li><li>解析Html元素</li><li>存储抓取到的数据<a id="more"></a></li></ul><h3 id="发起http请求"><a href="#发起http请求" class="headerlink" title="发起http请求"></a>发起http请求</h3><p>在请求方面，直接采用的Golang的”net/http”包来进行开发，步骤如下:</p><ul><li>初始化</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">client := &amp;http.Client&#123;&#125;</span><br><span class="line">req, err := http.NewRequest(&quot;GET&quot;, swoop.url, nil)</span><br></pre></td></tr></table></figure><ul><li>set请求信息</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for key, value := range swoop.header &#123;</span><br><span class="line">    req.Header.Add(key, value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>发起请求</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">resp, err := client.Do(req)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    log.Fatalf(&quot;do client err-&gt;%v&quot;, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>接收响应</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">body, err := ioutil.ReadAll(resp.Body)</span><br><span class="line">if err != nil &#123;</span><br><span class="line">    log.Fatalf(&quot;read resp err-&gt;%v&quot;, err)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="解析Html元素"><a href="#解析Html元素" class="headerlink" title="解析Html元素"></a>解析Html元素</h3><ul><li>设置参数并请求<br>首先需要定义个设置参数结构体，便于操作:</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">type Swoop struct &#123;</span><br><span class="line">    url    string</span><br><span class="line">    header map[string]string</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>设置参数后发起请求<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">url := &quot;https://movie.douban.com/top250?start=&quot; + strconv.Itoa(i*25)</span><br><span class="line">swoop := &amp;Swoop&#123;url, header&#125;</span><br><span class="line">html := swoop.get_html_header()</span><br></pre></td></tr></table></figure></p><ul><li>解析Html元素<br>发起请求后，接收到Html元素，接下来需要做的就是解析Html元素，将其转化为我们想要的格式，解析Html格式需要到页面浏览器查看对应的Html元素后再做操作：</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">//评价人数</span><br><span class="line">commentCount := `&lt;span&gt;(.*?)评价&lt;/span&gt;`</span><br><span class="line">rp2 := regexp.MustCompile(commentCount)</span><br><span class="line">txt2 := rp2.FindAllStringSubmatch(html, -1)</span><br><span class="line"></span><br><span class="line">//评分</span><br><span class="line">pattern3 := `property=&quot;v:average&quot;&gt;(.*?)&lt;/span&gt;`</span><br><span class="line">rp3 := regexp.MustCompile(pattern3)</span><br><span class="line">txt3 := rp3.FindAllStringSubmatch(html, -1)</span><br><span class="line"></span><br><span class="line">//电影名称</span><br><span class="line">pattern4 := `img width=&quot;(.*?)&quot; alt=&quot;(.*?)&quot; src=`</span><br><span class="line">rp4 := regexp.MustCompile(pattern4)</span><br><span class="line">txt4 := rp4.FindAllStringSubmatch(html, -1)</span><br></pre></td></tr></table></figure><p>如下Html页面代码，其中评价包含在”&lt;\span&gt;”标签内，所以在解析的时候需要解析&lt;\span&gt;标签:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div class=&quot;star&quot;&gt;</span><br><span class="line">    &lt;span class=&quot;rating5-t&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span class=&quot;rating_num&quot; property=&quot;v:average&quot;&gt;9.5&lt;/span&gt;</span><br><span class="line">    &lt;span property=&quot;v:best&quot; content=&quot;10.0&quot;&gt;&lt;/span&gt;</span><br><span class="line">    &lt;span&gt;702861人评价&lt;/span&gt;</span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p><p>如下页面代码，包含了width、alt、src三个value，则需要拿到title就需要解析&lt;\img&gt;标签后读取第二个value值，即alt<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;img width=&quot;100&quot; alt=&quot;这个杀手不太冷&quot; src=&quot;https://img3.doubanio.com/view/photo/s_ratio_poster/public/p511118051.jpg&quot; class=&quot;&quot;&gt;</span><br></pre></td></tr></table></figure></p><ul><li>运行代码后效果如下<br>运行中:<br><img src="/2018/02/11/Golang实现的简单爬虫/2_run.png" alt="run"></li></ul><p>运行结束:<br><img src="/2018/02/11/Golang实现的简单爬虫/2_result.png" alt="result"></p><h3 id="数据存储"><a href="#数据存储" class="headerlink" title="数据存储"></a>数据存储</h3><p>数据存储一般根据自己的需要来做，我这里采用的是csv文件存储.<br>如下所示:<br><img src="/2018/02/11/Golang实现的简单爬虫/2_print.png" alt="print"></p><h4 id="GitHub"><a href="#GitHub" class="headerlink" title="GitHub"></a>GitHub</h4><p><a href="https://github.com/Swxctx/mygo/tree/master/swoop/douban" target="_blank" rel="noopener">源代码链接</a></p>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h3&gt;&lt;p&gt;今天在工作上面需要用到爬虫抓取部分信息，之前用Python实现了CSDN博客的抓取，后想到了目前整天面对的Golang，便摸索了一下，实现了一个简单的抓取豆瓣排行的爬虫，主要分为下面几个步骤.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;发起Http请求&lt;/li&gt;
&lt;li&gt;解析Html元素&lt;/li&gt;
&lt;li&gt;存储抓取到的数据&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="golang" scheme="http://www.swxctx.top/categories/golang/"/>
    
    
      <category term="Golang" scheme="http://www.swxctx.top/tags/Golang/"/>
    
  </entry>
  
  <entry>
    <title>First Content</title>
    <link href="http://www.swxctx.top/2018/01/24/first-blog/"/>
    <id>http://www.swxctx.top/2018/01/24/first-blog/</id>
    <published>2018-01-24T06:08:20.000Z</published>
    <updated>2018-01-24T10:32:46.000Z</updated>
    
    <content type="html"><![CDATA[<h3 id="序言"><a href="#序言" class="headerlink" title="序言"></a>序言</h3><p>该网站主要用于记录日常工作及学习中的一些知识点及简要代码，主要包含如下几类。</p><ul><li>Golang</li><li>C</li><li>C++</li><li>Java</li><li>机器学习</li><li>日常算法及文章分享</li><li>Linux编程及日常服务器维护<a id="more"></a>如果有错误或不好的地方可通过’关于我’页面的联系方式与我联系，或者点击文章下方进行评论。</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;h3 id=&quot;序言&quot;&gt;&lt;a href=&quot;#序言&quot; class=&quot;headerlink&quot; title=&quot;序言&quot;&gt;&lt;/a&gt;序言&lt;/h3&gt;&lt;p&gt;该网站主要用于记录日常工作及学习中的一些知识点及简要代码，主要包含如下几类。&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Golang&lt;/li&gt;
&lt;li&gt;C&lt;/li&gt;
&lt;li&gt;C++&lt;/li&gt;
&lt;li&gt;Java&lt;/li&gt;
&lt;li&gt;机器学习&lt;/li&gt;
&lt;li&gt;日常算法及文章分享&lt;/li&gt;
&lt;li&gt;Linux编程及日常服务器维护&lt;/li&gt;&lt;/ul&gt;
    
    </summary>
    
      <category term="base" scheme="http://www.swxctx.top/categories/base/"/>
    
    
      <category term="基础" scheme="http://www.swxctx.top/tags/%E5%9F%BA%E7%A1%80/"/>
    
  </entry>
  
</feed>
